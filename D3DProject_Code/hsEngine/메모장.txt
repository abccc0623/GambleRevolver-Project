


까먹는거 정리

////////////////////////////////////////////////////////////
밉 맵핑
////////////////////////////////////////////////////////////

벽이 화면의 64 x 64픽셀을 차지할 정도로 작아지면 256 x 256개의 픽셀이 
64 x 64개의 화면 픽셀에 입혀지게 된다.
이 경우에도 대체로 픽셀의 텍스처 좌표가 텍스처
맵의 그 어떤 픽셀 점과도 일치하지 않으며，따라서 상수 보간 필터링이나 선형 보간 필터링
이 적용된다.그런데 축소에 대해서는 그런 필터링 이외의 처리가 가능하다.이런 상황게서는
256 x 256텍셀 크기의 맵을 일종의 평균 하향표본화(donwsampling)를 통해 64 x 64 크기의
더 작은 맵으로 줄일 수 있음을 눈치챘을 것이다
이점을 이용해서 (대신 메모리를 더사용함..) 축소를 효율적으로 근사하는 기법이 밉맵핑



////////////////////////////////////////////////////////////
D3D11_TEXTURE2D_DESC 구조체 정리
////////////////////////////////////////////////////////////
D3D11_TEXTURE2D_DESC texDesc;
texDesc.Width			= ENGINE->mClientWidth;; //텍스쳐가로 
texDesc.Height			= ENGINE->mClientWidth;; //텍스쳐세로
texDesc.MipLevels		= 1; 밉맵수준 (깊이 스텐실 버퍼를 위한텍스쳐에서는 하나만있으면된다)
texDesc.ArraySize		= 1; 택스쳐 배열의택스쳐 개수 (깊이 스텐실 버퍼를 위한텍스쳐에서는 하나만있으면된다)
texDesc.Format			= DXGI_FORMAT_R8G8B8A8_UNORM;	//픽셀의 형식을 뜻함

//4X MSAA를 사용하는가? 반드시 교환 사슬과 일치해야 한다
texDesc.SampleDesc.Count = 1;	
texDesc.SampleDesc.Quality = 0;

texDesc.Usage = D3D11_USAGE_DEFAULT;//텍스쳐의 용도
1)	D3D11_USAGE_DEFAULT; 자원을 GPU가 읽고 써야한다면 이걸로 대신 CPU에서는 쓸수없다
2)	D3D11_USAGE_IMMUTABLE; 자원을 생성한후에 그내용이 바꾸지 않는 경우에 이거
3)	D3D11_USAGE_DYNAMIC; CPU가 자원의 내용을 빈번하게 (ex 프레임마다) 갱신해야한다면 이걸로
4)	D3D11_USAGE_STAGING; CPU에서 자원이 자료를 비디오 메모리에서 시스템 메모리로 전송할수 있어야할떄.. 뭔소리?
	암튼 GPU에서 CPU메모리로 자료 복사는 느린연산이여서 피해야한다

//자원을 파이프라인에 어떤 식으로 묶을 것인지를 지정하는 하나이상의 플래그
texDesc.BindFlags = D3D11_BIND_RENDER_TARGET | D3D11_BIND_SHADER_RESOURCE | D3D11_BIND_DEPTH_STENCIL;
1)	D3D11_BIND_DEPTH_STENCIL 스텐실 버퍼
2)	D3D11_BIND_RENDER_TARGET 랜더타겟
3)	D3D11_BIND_SHADER_RESOURCE 쉐이더 리소스

texDesc.CPUAccessFlags = 0;//CPUrk 자원에 접근하는 방식을 결정하는 플래그들을 지정한다
1)	CPU가 자원에 자료를 기록해야 한다면 D3D11_CPU_ACCECSS_WRITE지정
	CPU의 쓰기 접근이 가능하려면  D3D11_USAGE_DYNAMIC 이나  D3D11_USAGE_STAGING 이어야 한다 (주의)
2)	CPU의 읽기 접근이 가능하려면	D3D11_CPU_ACCECSS_READ 이걸쓰려면 자원의 용도가 D3D11_USAGE_STAGING 이어야한다
	깊이 스텐실 버퍼의 경우 GPU만 깊이 스텐실 버퍼를 읽고 쓸뿐 CPU는 접근하지않으므로 그냥 0을 지정하면된다

texDesc.MiscFlags = 0;//| D3D11_RESOURCE_MISC_TEXTURECUBE;
기타 플래그들로 깊이 스텐실 버퍼에는 적용되지 않으므로 그냥 0을 지정하면된다



////////////////////////////////////////////////////////////
포스트 프로세싱
////////////////////////////////////////////////////////////
포스트 프로세싱은 기존에 렌더링된 씬에 렌더링 효과를 더하는 작업입니다.
포스트 프로세싱의 효과는 일반적으로 Scene 뷰에 따라 달라지거나
최종 렌더링 결과물을 생성하기 전에 렌더링되는 씬 위에 겹쳐서 표시됩니다.
이 기능은 기존 콘텐츠를 수정할 필요 없이 시각적인 효과를 즉시 구현하고 씬의 품질을 한층 개선할 수 있다는 뚜렷한 장점이 있습니다



////////////////////////////////////////////////////////////
안티앨리어싱
////////////////////////////////////////////////////////////
3D 폴리곤을 해상도가 제한된 2D 화면으로 래스터화하는 경우
최종 픽셀에 앨리어싱 효과(오브젝트 모서리가 계단처럼 표시)가 발생합니다.
실시간 3D에는 슈퍼샘플링, 멀티샘플 안티앨리어싱(MSAA), 빠른 근사 안티앨리어싱(FXAA),
공간적 안티앨리어싱(SMAA), 시간적 안티앨리어싱(TXAA) 등 다양한 안티앨리어싱 기술이 있습니다




////////////////////////////////////////////////////////////
쉐이더 함수들
////////////////////////////////////////////////////////////
cross					: 두 백터의 외적 리턴값은 float3
mul						: 두	 행렬의 곱
tex2D(s, t, ddx, ddy)	: 2D의 투영 텍스처 참조.
clip(x)					: x의 한 원소가 0보다 작으면 현재 픽셀을 버린다. 
						  x의 각 성분이 면으로부터의 거리를 나타내는 경우,
						  이 함수를 사용해, 클립면을 시뮬레이션 한다. (픽셀 쉐이더 에서만 가능)


////////////////////////////////////////////////////////////
HDR
////////////////////////////////////////////////////////////
HDR은 High Dynamic Range의 약자로, 어두운 곳에서 밝은 곳까지 더 넓어진 밝기의 범위
(다이나믹 레인지)를 기존 SDR (Standard Dynamic Range)과 비교하여 표시 할 수 있습니다.
김용준교수님의 PPT에 나와있다... 밝은부분을 추출하기위해 사용됨
Bloom Curve


////////////////////////////////////////////////////////////
FX 와 HLSL
////////////////////////////////////////////////////////////
Fx파일 (쉐이더의 소스코드가 들어있는 텍스트 파일) 로드해서 D3DXCreateEffectFromFile함수 내에서 컴파일 하여 실행하는 방법은
각 쉐이더 클래스 초기화시 컴파일하게 되기 때문에 그만큼의 부하가 발생
또 배포시 텍스트 파일인 fx파일도 같이 배포 해야 하기 때문에 다른 사람이 임의로 수정이 가능하므로 그다지 좋은 방법이아님

이것에 대응하는 두가지의 방법
1. 바이너리 데이터를 오브젝트 파일로 출력한다
	실행시에 컴파일 할 필요는 없지만 오브젝트 파일을 같이 배포해야한다

2. 바이너리 데이터를 헤더파일로 출력한다
	실행시에 컴파일할 필요도 따로 배포할 파일도 없다 헤더 파일이기 때문에 오브젝트의 인클루드 해서 컴파일하며
	실행파일에 들어있다


////////////////////////////////////////////////////////////
D3D11_SAMPLER_DESC 구조체 설명
////////////////////////////////////////////////////////////
D3D11_FILTER				Filter;			텍스쳐를 샘플링할때 사용할 필터링 방법
D3D11_TEXTURE_ADDRESS_MODE	AddressU;		0~1 범위를 벗어나는 u텍스쳐 좌표를 해결하는데 사용하는방법
D3D11_TEXTURE_ADDRESS_MODE	AddressV;		0~1 범위를 벗어나는 v텍스쳐 좌표를 해결하는데 사용하는방법
D3D11_TEXTURE_ADDRESS_MODE	AddressW;		0~1 범위를 벗어나는 w텍스쳐 좌표를 해결하는데 사용하는방법
FLOAT						MipLODBias;		계산된 맵 수준에서 오프셋. (뭔말?)
UINT						MaxAnisotropy;	클램핑값 1~16 사이
D3D11_COMPARISON_FUNC		ComparisonFunc;	샘플링된 데이터를 기존 새플링된 데이터와 비교하는 함수
FLOAT						BorderColor[4];	D3D11_TEX일 경우테두리 색주소u ,주소v 주소w 에 대해 TURE_ADDRESS_BORDERTER 지정
FLOAT						MinLOD;			
FLOAT						MaxLOD;



////////////////////////////////////////////////////////////
XMMatrixTranspose
////////////////////////////////////////////////////////////
DirectX에서는 행렬 순서가 row-major(행우선)이고, HLSL에서는 column-major(열우선)이다.

서로간의 행렬 순서가 달랐기 때문에, DirectX에서는 'World * View * Projection' 순으로 연산하는것을

셰이더(HLSL)에서는 'Projection * View * World'로 연산해야 제대로 된 결과값이 나왔던 것이다.